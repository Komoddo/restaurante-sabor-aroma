# -*- coding: utf-8 -*-
"""Copia de Modelo_veterinaria.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1D3oiIcbdcH9NZS-irntMdGkGFtjBEYm1
"""

# üêæ SISTEMA DE GESTI√ìN PARA VETERINARIA
# Proyecto Integrador Transversal
# Cursos: Fundamentos de Programaci√≥n + Fundamentos de Gesti√≥n de Datos

import sqlite3
import datetime
import csv
import pandas as pd
import matplotlib.pyplot as plt
import os
from typing import List, Dict, Tuple, Optional
from Modelo.Producto import Producto
from Servicio.producto_servicio import ProductoServicio

from base_datos.restaurante_db import RestaurantDB

from Presentacion.menu_principal import menu_principal


# ============================================================================
# CLASE PRINCIPAL CON TODAS LAS MEJORAS INTEGRADAS
# ============================================================================

class RestauranteGestion:
    
    def __init__(self):
        """
        Inicializa el sistema de gesti√≥n de restaurante.
        """
        RestaurantDB()
        mesa_servicio = Mesa_Servicio()
        self.producto_servicio = ProductoServicio()

        # Cat√°logo de productos
        self.Catalogo = [
            Producto(0, "Caf√© Americano", "Caf√© filtrado tradicional", 1.80, "Bebida", 1),
            Producto(0, "Cappuccino", "Caf√© con leche y espuma", 2.50, "Bebida", 1),
            Producto(0, "T√© de Hierbas", "Infusi√≥n natural de hierbas", 1.60, "Bebida", 1),
            Producto(0, "T√© Verde", "T√© verde org√°nico", 1.70, "Bebida", 0),
            Producto(0, "Latte", "Caf√© con leche espumada", 2.40, "Bebida", 1),
            Producto(0, "Mocaccino", "Caf√© con chocolate y espuma", 2.90, "Bebida", 0),
            Producto(0, "Espresso", "Caf√© espresso intenso", 1.30, "Bebida", 1),
            Producto(0, "Caf√© Doble", "Doble shot de espresso", 2.10, "Bebida", 1),
            Producto(0, "Caf√© con Leche", "Caf√© con bastante leche", 2.00, "Bebida", 1),
            Producto(0, "Brownie Casero", "Porci√≥n de brownie con nuez", 2.90, "Postre", 1),
            Producto(0, "Cheesecake", "Tarta de queso individual", 3.50, "Postre", 0),
            Producto(0, "Tarta de Manzana", "Tarta tibia con crumble", 3.20, "Postre", 1),
            Producto(0, "Muffin Ar√°ndanos", "Muffin reci√©n horneado", 1.90, "Postre", 1),
            Producto(0, "Helado Vainilla", "Copa de helado crema vainilla", 2.10, "Postre", 0),
            Producto(0, "Ensalada C√©sar", "Lechuga, pollo y aderezo C√©sar", 4.20, "Men√∫", 0),
            Producto(0, "Ensalada Mixta", "Mix de hojas, tomate y zanahoria", 3.80, "Men√∫", 1),
            Producto(0, "S√°ndwich Veggie", "Pan integral con verduras grilladas", 3.80, "Men√∫", 1),
            Producto(0, "S√°ndwich de At√∫n", "At√∫n, mayonesa ligera y lechuga", 3.60, "Men√∫", 1),
            Producto(0, "Wrap Pollo", "Wrap de pollo a la plancha", 4.00, "Men√∫", 0),
            Producto(0, "Pizza Personal", "Pizza peque√±a de queso y tomate", 4.90, "Men√∫", 1),
            Producto(0, "Hamburguesa Cl√°sica", "Carne, queso y vegetales", 5.20, "Men√∫", 1),
            Producto(0, "Papas Fritas", "Porci√≥n crujiente", 1.80, "Snack", 1),
            Producto(0, "Sopa del D√≠a", "Sopa casera seg√∫n disponibilidad", 2.50, "Entradas", 0),
            Producto(0, "Jugo Naranja", "Jugo natural exprimido", 1.70, "Bebida Fr√≠a", 1),
            Producto(0, "Smoothie Frutos Rojos", "Batido de frutas y yogur", 3.10, "Bebida Fr√≠a", 0),
        ]
        self.Categorias = {}
        self.crear_categorias()
        
        # self.empleados = [
        #     ("Carlos", "P√©rez", "12345678", 30, "Cocina"),
        #     ("Mar√≠a", "Gonz√°lez", "87654321", 28, "Atenci√≥n al Cliente"),
        #     ("Juan", "Ram√≠rez", "11223344", 35, "Gerencia"),
        #     ("Luc√≠a", "Fern√°ndez", "44332211", 25, "Limpieza"),
        #     ("Pedro", "Salazar", "55667788", 40, "Administraci√≥n"),
        #     ("Ana", "Torres", "99887766", 32, "Cocina"),
        #     ("Luis", "Mendoza", "22334455", 29, "Atenci√≥n al Cliente"),
        #     ("Carla", "Vargas", "33445566", 27, "Gerencia"),
        #     ("Miguel", "L√≥pez", "44556677", 31, "Limpieza"),
        #     ("Daniela", "Campos", "55667788", 26, "Administraci√≥n")
        # ]

        # self.clientes = [
        #     ("Mar√≠a", "Gonz√°lez P√©rez", "987654321", "maria.gonzalezp@gmail.com"),
        #     ("Juan", "Ram√≠rez Torres", "912345678", "juan.ramirezto@gmail.com"),
        #     ("Luc√≠a", "Fern√°ndez Rojas", "954321678", "lucia.fernandezr@gmail.com"),
        #     ("Pedro", "Salazar Quiroz", "998877665", "pedro.salazarq@gmail.com"),
        #     ("Ana", "Torres Delgado", "934567812", "ana.torresd@gmail.com"),
        #     ("Luis", "Mendoza L√≥pez", "987123654", "luis.mendozal@gmail.com"),
        #     ("Carla", "Vargas Castillo", "945612378", "carla.vargasc@gmail.com"),
        #     ("Miguel", "L√≥pez Herrera", "976543210", "miguel.lopezh@gmail.com"),
        #     ("Daniela", "Campos Rivera", "956781234", "daniela.camposr@gmail.com"),
        #     ("Jos√©", "P√©rez Aguilar", "934125678", "jose.perezag@gmail.com"),
        #     ("Valeria", "Rojas Medina", "987456321", "valeria.rojasm@gmail.com"),
        #     ("Andr√©s", "Su√°rez Ram√≠rez", "912398765", "andres.suarezr@gmail.com"),
        #     ("Gabriela", "Ch√°vez Flores", "956234781", "gabriela.chavezf@gmail.com"),
        #     ("Roberto", "Morales Vega", "945673218", "roberto.moralesv@gmail.com"),
        #     ("Patricia", "Herrera Campos", "987612345", "patricia.herrerac@gmail.com"),
        #     ("Sof√≠a", "Cruz Andrade", "954789123", "sofia.cruza@gmail.com"),
        #     ("Fernando", "Silva N√∫√±ez", "976128345", "fernando.silvan@gmail.com"),
        #     ("Roc√≠o", "Delgado Ponce", "912764389", "rocio.delgadop@gmail.com"),
        #     ("Diego", "Ortega Cabrera", "934876512", "diego.ortegac@gmail.com"),
        #     ("Elena", "Paredes Soto", "987341256", "elena.paredess@gmail.com")
        #    ]
        
        # self.mesas = [
        #     ("M1", 2, "Disponible"),
        #     ("M2", 2, "Disponible"),
        #     ("M3", 2, "Disponible"),
        #     ("M4", 2, "Disponible"),
        #     ("M5", 4, "Disponible"),
        #     ("M6", 4, "Disponible"),
        #     ("M7", 4, "Disponible"),
        #     ("M8", 4, "Disponible"),
        #     ("M9", 8, "Disponible"),
        #     ("M10", 8, "Ocupado"),
        #     ("M11", 8, "Ocupado"),
        #     ("M12", 8, "Ocupado")
        #    ]
        
        # self.estado_mesa = {"Disponible", "Ocupado", "Reservado"}

        # # Historial de ventas y carrito
        # self.ventas = []
        self.carrito = []

        # Configurar directorios e inicializar
        self.crear_directorios()
        self.Insertar_datos_prueba()
        #self.inicializar_base_datos()

    def crear_categorias(self):
        self.cat = sorted({p.categoria for p in self.Catalogo})
        self.Categorias = {i: cat for i, cat in enumerate(self.cat, start=1)}
   
    def crear_directorios(self):
        """Crea la estructura de directorios necesaria."""
        directorios = ['datos', 'datos/backup', 'base_datos', 'reportes', 'reportes/graficos']
        for directorio in directorios:
            os.makedirs(directorio, exist_ok=True)
        print("‚úÖ Estructura de directorios creada correctamente")

    # ========================================================================
    # FUNCIONES DEL CAT√ÅLOGO Y PRODUCTOS
    # ========================================================================
    def Insertar_datos_prueba(self):
        try:
            vacio = self.producto_servicio.validar_productos()
            if vacio:
                for producto in self.Catalogo:
                    self.producto_servicio.agregar_producto(producto)
        except Exception as e:
            print(f"Error al insertar datos de prueba: {e}")

    def mostrar_catalogo(self):
        """Muestra el cat√°logo completo de productos."""
        print("\n" + "="*60)
        print("CAT√ÅLOGO PRODUCTOS - RESTAURANTE")
        print("="*60)

        self.Catalogo.clear()
        self.LstProductos =  self.producto_servicio.obtener_productos()
        self.Catalogo = [p for p in self.LstProductos if p.disponibilidad]
        categorias = {}
        for item in self.Catalogo:
            categoria = item.categoria
            if categoria not in categorias:
                categorias[categoria] = []
            categorias[categoria].append(item)

        for categoria, items in categorias.items():
            print(f"\nüìã {categoria.upper()}")
            print("-" * 40)
            for p in items:
                print(f"‚Ä¢ {p.nombre:<25} | {p.descripcion:<45} | S/{p.precio:>6.2f}")

    def filtrar_catalogo(self, nombre: str):
        """Busca un producto espec√≠fico en el cat√°logo."""
        nombre_lower = nombre.lower().strip()
        lst_busqueda = [p for p in self.Catalogo if nombre_lower in p.nombre.lower()]
        if lst_busqueda:
            return lst_busqueda
        return None
                   
    def agregar_al_carrito(self, nombre: str, cantidad: int) -> bool:
        """Agrega un producto al carrito con validaci√≥n de stock."""
        try:
            filtrado = self.filtrar_catalogo(nombre)
            if not filtrado:
                print(f" Producto '{nombre}' no encontrado")
                return False
            else:
                for p in filtrado:
                    print(f"‚Ä¢ {p.id_producto}     {p.nombre:<25} | {p.descripcion:<45} |    {p.categoria:<45}  |   S/{p.precio:>6.2f}")
            
                            
            # Verificar si ya est√° en el carrito
            for i, item in enumerate(self.carrito):
                if item[0] == nombre_prod:
                    nueva_cantidad = item[2] + cantidad
                    # if stock < nueva_cantidad:
                    #     print(f" Stock insuficiente para agregar m√°s unidades")
                    #     return False
                    self.carrito[i] = (nombre_prod, precio, nueva_cantidad)
                    print(f" Cantidad actualizada en carrito: {nombre_prod} x{nueva_cantidad}")
                    return True

            # Agregar nuevo item al carrito
            self.carrito.append((nombre_prod, precio, cantidad))
            print(f" Agregado al carrito: {nombre_prod} x {cantidad}")
            return True

        except Exception as e:
            print(f" Error al agregar al carrito: {e}")
            return False

    def mostrar_carrito(self):
        """Muestra el contenido actual del carrito."""
        if not self.carrito:
            print("üõí El carrito est√° vac√≠o")
            return

        print("\n" + "="*50)
        print("üõí CARRITO DE COMPRAS")
        print("="*50)
        total = 0
        for nombre, precio, cantidad in self.carrito:
            subtotal = precio * cantidad
            total += subtotal
            print(f"‚Ä¢ {nombre:<25}  |  S/{precio:>6.2f} x {cantidad} = S/{subtotal:>8.2f}")
        print("-" * 50)
        print(f"TOTAL: S/{total:.2f}")

    def gestionar_reservas():
        # Aqu√≠ se implementar√≠a la l√≥gica para gestionar reservas
        # incluyendo agregar, modificar, cancelar y ver reservas.
        while True:
            """Funci√≥n para gestionar reservas de mesas."""
            print("\nüîñ GESTI√ìN DE RESERVAS - RESTAURANTE")
            print("="*60)
            print("Funcionalidad en desarrollo...")
            print("\n" + "="*60)
            print("1. üí∞ Mostrar Lista de Reservas")
            print("2. üí∞ Agregar Reserva")
            
    def mostrar_mesasss(self):
        """Funci√≥n para mostrar las mesas y su estado."""
        print("\nüîñ LISTA DE MESAS")
        print("="*60)
        # Agrupar mesas por estado
        mesas_agrupadas = {}
        for numero, capacidad, estado in self.mesas:
            if estado not in mesas_agrupadas:
                mesas_agrupadas[estado] = []
            mesas_agrupadas[estado].append((numero, capacidad))

        for estado, mesas in mesas_agrupadas.items():
            print(f"\nEstado: {estado}")
            for numero, capacidad in mesas:
                print(f"Mesa {numero} - Capacidad: {capacidad}")

    def Agregar_reserva():
        # Aqu√≠ se implementar√≠a la l√≥gica para agregar una reserva
        print("\nüîñ AGREGAR RESERVA")
        print("="*60)

        self.mostrar_mesas()
        mesa_seleccionada = input("Seleccione el n√∫mero de mesa: ").strip()

        # Verificar si la mesa est√° disponible
        mesa_disponible = next((mesa for mesa in self.mesas if mesa[0] == mesa_seleccionada and mesa[2] == "Disponible"), None)
        if not mesa_disponible:
            print("Mesa no disponible. Intente con otra mesa.")
            return

        # Mostrar clientes registrados
        print("\nüë• CLIENTES REGISTRADOS")
        for i, cliente in enumerate(self.clientes, 1):
            print(f"{i}. {cliente[0]} {cliente[1]} - {cliente[2]}")

        cliente_seleccionado = int(input("Seleccione el n√∫mero de cliente: ")) - 1
        if cliente_seleccionado < 0 or cliente_seleccionado >= len(self.clientes):
            print("Cliente no v√°lido.")
            return

        fecha_reserva = input("Ingrese la fecha de la reserva (YYYY-MM-DD): ")
        hora_reserva = input("Ingrese la hora de la reserva (HH:MM): ")

        # Registrar la reserva
        reserva = {
            "idMesa": mesa_seleccionada,
            "idCliente": self.clientes[cliente_seleccionado][2],
            "fecha": fecha_reserva,
            "hora": hora_reserva
        }
        print(f"Reserva registrada: Mesa {mesa_seleccionada} para {self.clientes[cliente_seleccionado][0]} {self.clientes[cliente_seleccionado][1]} el {fecha_reserva} a las {hora_reserva}.")

    # ========================================================================
    # FUNCIONES DE VENTAS
    # ========================================================================

    def aplicar_descuento(self, total: float, tipo_cliente: str) -> Tuple[float, float]:
        """Aplica descuentos seg√∫n el tipo de cliente."""
        descuentos = {"premium": 0.15, "regular": 0.05}
        porcentaje = descuentos.get(tipo_cliente, 0)
        descuento_aplicado = total * porcentaje
        total_final = total - descuento_aplicado
        return total_final, porcentaje * 100

    def finalizar_compra(self, cliente_id: int) -> bool:
        """Procesa la compra final."""
        try:
            if not self.carrito:
                print(" El carrito est√° vac√≠o")
                return False

            cliente = next((c for c in self.clientes if c["id"] == cliente_id), None)
            if not cliente:
                print(f" Cliente con ID {cliente_id} no encontrado")
                return False

            # Calcular totales
            subtotal = sum(precio * cantidad for _, precio, cantidad, _ in self.carrito)
            total_final, descuento_pct = self.aplicar_descuento(subtotal, cliente["tipo"])

            # Actualizar stock en cat√°logo
            for item_carrito in self.carrito:
                nombre_carrito = item_carrito[0]
                cantidad_carrito = item_carrito[2]
                for i, item_catalogo in enumerate(self.catalogo):
                    if item_catalogo[0] == nombre_carrito:
                        nombre, precio, stock, categoria = item_catalogo
                        nuevo_stock = stock - cantidad_carrito
                        self.catalogo[i] = (nombre, precio, nuevo_stock, categoria)
                        break

            # Registrar venta
            venta = {
                "fecha": datetime.datetime.now(),
                "cliente": cliente["nombre"],
                "cliente_id": cliente_id,
                "items": self.carrito.copy(),
                "subtotal": subtotal,
                "descuento_pct": descuento_pct,
                "total": total_final
            }

            self.registrar_venta(venta)
            self.mostrar_ticket_venta(venta)
            self.carrito.clear()
            return True

        except Exception as e:
            print(f" Error al finalizar compra: {e}")
            return False

    def registrar_venta(self, venta: Dict):
        """Registra una venta en el historial."""
        self.ventas.append(venta)
        self.insertar_venta_bd(venta)
        self.guardar_venta_archivo(venta)

    def mostrar_ticket_venta(self, venta: Dict):
        """Muestra el ticket de venta."""
        print("\n" + "="*60)
        print("üêæ VETERINARIA HUELLITAS - TICKET DE VENTA")
        print("="*60)
        print(f"Fecha: {venta['fecha'].strftime('%d/%m/%Y %H:%M:%S')}")
        print(f"Cliente: {venta['cliente']}")
        print("-" * 60)

        for nombre, precio, cantidad, _ in venta["items"]:
            subtotal = precio * cantidad
            print(f"{nombre:<35} {cantidad:>3} x S/{precio:>6.2f} = S/{subtotal:>8.2f}")

        print("-" * 60)
        print(f"Subtotal: {venta['subtotal']:>46.2f}")
        if venta['descuento_pct'] > 0:
            descuento_monto = venta['subtotal'] - venta['total']
            print(f"Descuento ({venta['descuento_pct']:.0f}%): {descuento_monto:>38.2f}")
        print(f"TOTAL: S/{venta['total']:>45.2f}")
        print("="*60)
        print("¬°Gracias por confiar en nosotros! üêæ")

    def mostrar_historial(self):
        """Muestra el historial de ventas."""
        if not self.ventas:
            print("üìä No hay ventas registradas")
            return

        print("\n" + "="*80)
        print(" HISTORIAL DE VENTAS")
        print("="*80)
        total_ventas = 0
        for i, venta in enumerate(self.ventas, 1):
            fecha_str = venta["fecha"].strftime('%d/%m/%Y %H:%M')
            print(f"{i:>3}. {fecha_str} | {venta['cliente']:<20} | S/{venta['total']:>8.2f}")
            total_ventas += venta['total']
        print("-" * 80)
        print(f"Total de ventas: {len(self.ventas)} | Monto total: S/{total_ventas:.2f}")

    # ========================================================================
    # BASE DE DATOS
    # ========================================================================

    def inicializar_base_datos(self):
        """Crea las tablas necesarias en SQLite."""
        try:
            conn = sqlite3.connect('base_datos/restaurante.db')
            cursor = conn.cursor()

            

            

            
            

            # Tabla de reservas
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS reservas (
                    idReserva INTEGER PRIMARY KEY AUTOINCREMENT,
                    idMesa  INTEGER NOT NULL,
                    idCliente INTEGER,
                    fecha    TEXT,
                    hora    TEXT,
                    fecha_registro DATETIME DEFAULT CURRENT_TIMESTAMP,                      
                    FOREIGN KEY (idCliente) REFERENCES clientes (idCliente),
                    FOREIGN KEY (idMesa) REFERENCES mesas (idMesa)
                )
            ''')

            

            

            # Tabla de auditor√≠a de precios
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS auditoria_precios (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    fecha_cambio DATE NOT NULL,
                    idProducto INTEGER NOT NULL,
                    precio_anterior REAL,
                    precio_nuevo REAL NOT NULL,
                    fecha_registro DATETIME DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (idProducto) REFERENCES productos (idProducto)       
                )
            ''')

            self.insertar_datos_iniciales(cursor)
            conn.commit()
            conn.close()
            print("‚úÖ Base de datos inicializada correctamente")

        except Exception as e:
            print(f" Error al inicializar base de datos: {e}")

    def insertar_datos_iniciales(self, cursor):
        """Inserta datos de prueba si las tablas est√°n vac√≠as."""
        # Insertar productos del cat√°logo
        cursor.execute("SELECT COUNT(*) FROM productos")
        if cursor.fetchone()[0] == 0:
            for nombre, descripcion, precio, categoria in self.catalogo:
                cursor.execute('''
                    INSERT INTO productos (nombre, descripcion, precio, categoria)
                    VALUES (?, ?, ?, ?)
                ''', (nombre, descripcion, precio, categoria))

        # Insertar clientes
        cursor.execute("SELECT COUNT(*) FROM clientes")
        if cursor.fetchone()[0] == 0:
            for nombre, apellido, email, telefono in self.clientes:
                cursor.execute('''
                    INSERT INTO clientes (nombre, apellido, email, telefono)
                    VALUES (?, ?, ?, ?)
                ''', (nombre, apellido, email, telefono))

    # Insertar mesas
        cursor.execute("SELECT COUNT(*) FROM mesas")
        if cursor.fetchone()[0] == 0:
            for numero, capacidad, estadoMesa in self.mesas:
                cursor.execute('''
                    INSERT INTO mesas (numero, capacidad, estadoMesa)
                    VALUES (?, ?, ?)
                ''', (numero, capacidad, estadoMesa))


    def insertar_venta_bd(self, venta: Dict):
        """Inserta una venta en la base de datos."""
        try:
            conn = sqlite3.connect('base_datos/veterinaria.db')
            cursor = conn.cursor()

            cursor.execute('''
                INSERT INTO ventas (fecha, cliente_id, cliente_nombre, subtotal, descuento_pct, total)
                VALUES (?, ?, ?, ?, ?, ?)
            ''', (venta["fecha"], venta["cliente_id"], venta["cliente"],
                  venta["subtotal"], venta["descuento_pct"], venta["total"]))

            venta_id = cursor.lastrowid

            for nombre, precio, cantidad, _ in venta["items"]:
                subtotal_item = precio * cantidad
                cursor.execute('''
                    INSERT INTO detalle_ventas (venta_id, producto_nombre, precio_unitario, cantidad, subtotal)
                    VALUES (?, ?, ?, ?, ?)
                ''', (venta_id, nombre, precio, cantidad, subtotal_item))

            conn.commit()
            conn.close()

        except Exception as e:
            print(f" Error al insertar venta en BD: {e}")

    # ========================================================================
    # CONSULTAS SQL AVANZADAS
    # ========================================================================

    def productos_mas_vendidos(self, limite: int = 5):
        """Consulta los productos m√°s vendidos."""
        try:
            conn = sqlite3.connect('base_datos/restaurante.db')
            cursor = conn.cursor()

            cursor.execute('''
                SELECT
                    dv.producto_nombre,
                    SUM(dv.cantidad) as total_vendido,
                    SUM(dv.subtotal) as ingresos_total,
                    AVG(dv.precio_unitario) as precio_promedio
                FROM detalle_ventas dv
                JOIN ventas v ON dv.venta_id = v.id
                GROUP BY dv.producto_nombre
                ORDER BY total_vendido DESC
                LIMIT ?
            ''', (limite,))

            resultados = cursor.fetchall()
            conn.close()

            print(f"\n TOP {limite} PRODUCTOS M√ÅS VENDIDOS")
            print("="*70)
            print(f"{'Producto':<25} {'Cantidad':<10} {'Ingresos':<12} {'Precio Prom.'}")
            print("-"*70)
            for producto, cantidad, ingresos, precio_prom in resultados:
                print(f"{producto:<25} {cantidad:<10} S/{ingresos:<10.2f} S/{precio_prom:.2f}")

        except Exception as e:
            print(f" Error en consulta productos m√°s vendidos: {e}")

    def ventas_por_cliente(self):
        """Muestra las ventas agrupadas por cliente."""
        try:
            conn = sqlite3.connect('base_datos/veterinaria.db')
            cursor = conn.cursor()

            cursor.execute('''
                SELECT
                    c.nombre,
                    c.tipo,
                    COUNT(v.id) as total_compras,
                    SUM(v.total) as monto_total,
                    AVG(v.total) as ticket_promedio
                FROM clientes c
                LEFT JOIN ventas v ON c.id = v.cliente_id
                GROUP BY c.id, c.nombre, c.tipo
                ORDER BY monto_total DESC
            ''')

            resultados = cursor.fetchall()
            conn.close()

            print("\nüë• VENTAS POR CLIENTE")
            print("="*75)
            print(f"{'Cliente':<20} {'Tipo':<10} {'Compras':<8} {'Total':<12} {'Promedio'}")
            print("-"*75)
            for nombre, tipo, compras, total, promedio in resultados:
                total_str = f"S/{total:.2f}" if total else "S/0.00"
                promedio_str = f"S/{promedio:.2f}" if promedio else "S/0.00"
                print(f"{nombre:<20} {tipo:<10} {compras or 0:<8} {total_str:<12} {promedio_str}")

        except Exception as e:
            print(f" Error en consulta ventas por cliente: {e}")

    def productos_stock_critico(self, limite_stock: int = 10):
        """Identifica productos con stock cr√≠tico."""
        try:
            conn = sqlite3.connect('base_datos/veterinaria.db')
            cursor = conn.cursor()

            cursor.execute('''
                SELECT nombre, stock, categoria, precio
                FROM productos
                WHERE stock <= ?
                ORDER BY stock ASC, categoria
            ''', (limite_stock,))

            resultados = cursor.fetchall()
            conn.close()

            print(f"\n PRODUCTOS CON STOCK CR√çTICO (‚â§ {limite_stock})")
            print("="*60)
            print(f"{'Producto':<25} {'Stock':<8} {'Categor√≠a':<15} {'Precio'}")
            print("-"*60)
            for nombre, stock, categoria, precio in resultados:
                alerta = "üî¥" if stock == 0 else "üü°"
                print(f"{alerta} {nombre:<23} {stock:<8} {categoria:<15} S/{precio:.2f}")

        except Exception as e:
            print(f" Error en consulta stock cr√≠tico: {e}")

    # ========================================================================
    # SISTEMA DE ACTUALIZACIONES MEJORADO
    # ========================================================================

    def menu_actualizaciones(self):
        """Men√∫ especializado para gestionar todas las actualizaciones."""
        while True:
            print("\n" + "="*60)
            print("üîÑ MEN√ö DE ACTUALIZACIONES - RESTAURANTE")
            print("="*60)
            print("1. üí∞ Actualizar Precios de Productos")
            print("2. üì¶ Actualizar Stock/Inventario")
            print("3. üë• Gestionar Informaci√≥n de Clientes")
            print("4. üìã Agregar Nuevos Productos")
            print("5. üìÖ Programar Actualizaciones Futuras")
            print("6. üîç Ver Actualizaciones Pendientes")
            print("7. üìä Historial de Cambios (Auditor√≠a)")
            print("0. ‚¨ÖÔ∏è  Volver al Men√∫ Principal")
            print("="*60)

            try:
                opcion = input("Seleccione una opci√≥n: ").strip()

                if opcion == "1":
                    self.submenu_actualizar_precios()
                elif opcion == "2":
                    self.submenu_actualizar_stock()
                elif opcion == "3":
                    self.submenu_gestionar_clientes()
                elif opcion == "4":
                    self.submenu_agregar_productos()
                elif opcion == "5":
                    self.submenu_programar_actualizaciones()
                elif opcion == "6":
                    self.ver_actualizaciones_pendientes()
                elif opcion == "7":
                    self.ver_historial_cambios()
                elif opcion == "0":
                    print("Regresando al men√∫ principal...")
                    break
                else:
                    print(" Opci√≥n inv√°lida. Intente de nuevo.")

            except Exception as e:
                print(f" Error: {e}")
    
    def menu_gestionar_mesas(self):
        """Men√∫ para gestionar mesas del restaurante."""
        while True:
            print("\n" + "="*50)
            print("ü™ë GESTI√ìN DE MESAS")
            print("="*50)
            print("1. Ver todas las mesas")
            print("2. Agregar nueva mesa")
            print("3. Cambiar estado de mesa")
            print("4. Eliminar mesa")
            print("5. Ver mesas por estado")
            print("0. Volver")
            print("="*50)

            try:
                opcion = input("Seleccione una opci√≥n: ").strip()

                if opcion == "1":
                    self.mostrar_todas_mesas()
                elif opcion == "2":
                    self.agregar_mesa()
                elif opcion == "3":
                    self.cambiar_estado_mesa()
                elif opcion == "4":
                    self.eliminar_mesa()
                elif opcion == "5":
                    self.ver_mesas_por_estado()
                elif opcion == "0":
                    break
                else:
                    print("‚ùå Opci√≥n inv√°lida")

            except Exception as e:
                print(f"‚ùå Error: {e}")

    def mostrar_todas_mesas(self):
        """Muestra todas las mesas registradas."""
        print("\nü™ë LISTA COMPLETA DE MESAS")
        print("="*70)
        print(f"{'Num':<5} {'Capacidad':<12} {'Estado':<15} {'Descripci√≥n':<30}")
        print("-"*70)

        if not self.mesas:
            print("No hay mesas registradas")
            return

        for numero, capacidad, estado in self.mesas:
            print(f"{numero:<5} {capacidad:<12} {estado:<15}")
        print("-"*70)
        print(f"Total de mesas: {len(self.mesas)}")

    def agregar_mesa(self):
        """Agrega una nueva mesa al restaurante."""
        print("\n‚ûï AGREGAR NUEVA MESA")
        print("="*40)

        try:
            numero_mesa = input("N√∫mero de mesa (ej: 13, 14): ").strip()
            
            # Verificar que no exista una mesa con ese n√∫mero
            if any(mesa[0] == numero_mesa for mesa in self.mesas):
                print(f"‚ùå La mesa {numero_mesa} ya existe")
                return

            while True:
                try:
                    capacidad = int(input("Capacidad (personas): ").strip())
                    if capacidad > 0:
                        break
                    else:
                        print("‚ùå La capacidad debe ser mayor a 0")
                except ValueError:
                    print("‚ùå Ingrese un n√∫mero v√°lido")

            estado = "Disponible"

            print(f"\nüìã RESUMEN DE LA NUEVA MESA:")
            print(f"N√∫mero: {numero_mesa}")
            print(f"Capacidad: {capacidad} personas")
            print(f"Estado: {estado}")

            confirmar = input("\n¬øConfirmar creaci√≥n? (s/n): ").lower()
            if confirmar == 's':
                nueva_mesa = (numero_mesa, str(capacidad), estado)
                self.mesas.append(nueva_mesa)
                self.insertar_mesa_bd(numero_mesa, capacidad, estado)
                print(f"‚úÖ Mesa {numero_mesa} agregada exitosamente")
            else:
                print("‚ùå Operaci√≥n cancelada")

        except Exception as e:
            print(f"‚ùå Error al agregar mesa: {e}")

    def insertar_mesa_bd(self, numero, capacidad, estado):
        """Inserta una nueva mesa en la base de datos."""
        try:
            conn = sqlite3.connect('base_datos/restaurante.db')
            cursor = conn.cursor()

            cursor.execute('''
                INSERT INTO mesas (numero, capacidad, estadoMesa)
                VALUES (?, ?, ?)
            ''', (numero, capacidad, estado))

            conn.commit()
            conn.close()

        except Exception as e:
            print(f"‚ùå Error al guardar mesa en BD: {e}")

    def cambiar_estado_mesa(self):
        """Cambia el estado de una mesa."""
        print("\nüîÑ CAMBIAR ESTADO DE MESA")
        print("="*40)

        self.mostrar_todas_mesas()

        numero_mesa = input("\nIngrese el n√∫mero de mesa: ").strip()
        mesa = next((m for m in self.mesas if m[0] == numero_mesa), None)

        if not mesa:
            print(f"‚ùå Mesa {numero_mesa} no encontrada")
            return

        print(f"\nEstado actual: {mesa[2]}")
        print("\nNuevos estados disponibles:")
        estados_disponibles = list(self.estado_mesa)
        for i, est in enumerate(estados_disponibles, 1):
            print(f"{i}. {est}")

        try:
            opcion = int(input("\nSeleccione nuevo estado: ")) - 1
            if 0 <= opcion < len(estados_disponibles):
                nuevo_estado = estados_disponibles[opcion]
                
                # Actualizar en lista
                indice = self.mesas.index(mesa)
                self.mesas[indice] = (numero_mesa, mesa[1], nuevo_estado)
                
                # Actualizar en BD
                self.actualizar_estado_mesa_bd(numero_mesa, nuevo_estado)
                print(f"‚úÖ Mesa {numero_mesa}: {mesa[2]} ‚Üí {nuevo_estado}")
            else:
                print("‚ùå Opci√≥n inv√°lida")

        except ValueError:
            print("‚ùå Entrada inv√°lida")

    def actualizar_estado_mesa_bd(self, numero, nuevo_estado):
        """Actualiza el estado de una mesa en la BD."""
        try:
            conn = sqlite3.connect('base_datos/restaurante.db')
            cursor = conn.cursor()

            cursor.execute('''
                UPDATE mesas SET estadoMesa = ? WHERE numero = ?
            ''', (nuevo_estado, numero))

            conn.commit()
            conn.close()

        except Exception as e:
            print(f"‚ùå Error al actualizar mesa: {e}")

    def eliminar_mesa(self):
        """Elimina una mesa del rest2aurante."""
        print("\nüóëÔ∏è ELIMINAR MESA")
        print("="*40)

        self.mostrar_todas_mesas()

        numero_mesa = input("\nIngrese el n√∫mero de mesa a eliminar: ").strip()
        mesa = next((m for m in self.mesas if m[0] == numero_mesa), None)

        if not mesa:
            print(f"‚ùå Mesa {numero_mesa} no encontrada")
            return

        if mesa[2] == "Ocupado":
            print(f"‚ùå No se puede eliminar la mesa {numero_mesa}, est√° ocupada")
            return

        print(f"\n‚ö†Ô∏è Est√° a punto de eliminar:")
        print(f"Mesa {numero_mesa} - Capacidad: {mesa[1]} - Estado: {mesa[2]}")

        confirmar = input("\n¬øEst√° seguro? (s/n): ").lower()
        if confirmar == 's':
            self.mesas.remove(mesa)
            self.eliminar_mesa_bd(numero_mesa)
            print(f"‚úÖ Mesa {numero_mesa} eliminada exitosamente")
        else:
            print("‚ùå Operaci√≥n cancelada")

    def eliminar_mesa_bd(self, numero):
        """Elimina una mesa de la base de datos."""
        try:
            conn = sqlite3.connect('base_datos/restaurante.db')
            cursor = conn.cursor()

            cursor.execute('DELETE FROM mesas WHERE numero = ?', (numero,))

            conn.commit()
            conn.close()

        except Exception as e:
            print(f"‚ùå Error al eliminar mesa: {e}")

    def obtener_mesas_disponibles(self, num_personas: int) -> List[Tuple]:
        """Retorna una lista de mesas disponibles que cumplan con la capacidad requerida.
        
        Args:
            num_personas: N√∫mero de personas que necesitan mesa
            
        Returns:
            Lista de tuplas con mesas disponibles (numero, capacidad, estado)
        """
        mesas_disponibles = []
        

        for numero, capacidad, estado in self.mesas:
            try:
                if estado == "Disponible" and capacidad >= num_personas:
                    mesas_disponibles.append((numero, capacidad, estado))
            except ValueError:
                continue
        
        if mesas_disponibles:
            # Ordenar por capacidad ascendente para ofrecer la mesa m√°s peque√±a disponible
            mesas_disponibles.sort(key=lambda x: int(x[1]))
            
            print(f"\n‚úÖ MESAS DISPONIBLES PARA {num_personas} PERSONA(S)")
            print("="*50)
            print(f"{'ID'}  {'Mesa':<8} {'Capacidad':<12} {'Estado':<15}")
            print("-"*50)
            for numero, capacidad, estado in mesas_disponibles:
                print(f"{numero:<8} {capacidad:<12} {estado:<15}")
            print("-"*50)
            print(f"Total: {len(mesas_disponibles)} mesa(s) disponible(s)")
        else:
            print(f"\n‚ùå No hay mesas disponibles para {num_personas} persona(s)")
        
        return mesas_disponibles

    def ver_mesas_por_estado(self):
        """Muestra las mesas agrupadas por estado."""
        print("\nüìä MESAS POR ESTADO")
        print("="*50)

        mesas_por_estado = {}
        for numero, capacidad, estado in self.mesas:
            if estado not in mesas_por_estado:
                mesas_por_estado[estado] = []
            mesas_por_estado[estado].append((numero, capacidad))

        for estado in sorted(mesas_por_estado.keys()):
            mesas = mesas_por_estado[estado]
            print(f"\n{estado.upper()} ({len(mesas)} mesas):")
            print("-" * 40)
            for numero, capacidad in mesas:
                icono = "üü¢" if estado == "Disponible" else "üî¥" if estado == "Ocupado" else "üü°"
                print(f"{icono} Mesa {numero:<5} | Capacidad: {capacidad}")

    def submenu_actualizar_precios(self):
        """Submen√∫ interactivo para actualizar precios."""
        print("\n" + "="*50)
        print("üí∞ ACTUALIZACI√ìN DE PRECIOS")
        print("="*50)

        # Mostrar productos actuales
        print("\nüìã PRODUCTOS ACTUALES:")
        print("-" * 50)
        for i, (nombre, descripcion, precio, categoria) in enumerate(self.catalogo, 1):
            print(f"{i:2d}. {nombre:<25} |  {descripcion:<25} | S/{precio:>6.2f} | {categoria}")

        print("\n¬øC√≥mo desea actualizar los precios?")
        print("1. Actualizar precio de un producto espec√≠fico")
        print("2. Actualizar m√∫ltiples productos")
        print("3. Aplicar aumento/descuento porcentual por categor√≠a")
        print("0. Cancelar")

        try:
            opcion = input("\nSeleccione una opci√≥n: ").strip()

            if opcion == "1":
                self.actualizar_precio_individual()
            elif opcion == "2":
                self.actualizar_precios_multiple()
            elif opcion == "3":
                self.actualizar_precios_categoria()
            elif opcion == "0":
                return
            else:
                print("‚ùå Opci√≥n inv√°lida")

        except Exception as e:
            print(f"‚ùå Error: {e}")

    def actualizar_precio_individual(self):
        """Actualiza el precio de un producto espec√≠fico."""
        print("\nüéØ ACTUALIZAR PRECIO INDIVIDUAL")
        print("-" * 40)

        nombre_producto = input("Ingrese el nombre del producto: ").strip()
        producto = self.buscar_producto(nombre_producto)

        if not producto:
            print(f" Producto '{nombre_producto}' no encontrado")
            return

        nombre, descripcion, precio_actual, categoria = producto
        print(f"\n‚úÖ Producto encontrado:")
        print(f"Nombre: {nombre}")
        print(f"Descripci√≥n: {descripcion}")
        print(f"Precio actual: S/{precio_actual:.2f}")
        print(f"Categor√≠a: {categoria}")

        confirmar = input(f"\n¬øDesea actualizar el precio de '{nombre}'? (s/n): ").lower()
        if confirmar != 's':
            print(" Operaci√≥n cancelada")
            return

        try:
            nuevo_precio = float(input(f"Ingrese el nuevo precio (actual: S/{precio_actual:.2f}): "))

            if nuevo_precio <= 0:
                print(" El precio debe ser mayor a 0")
                return

            # Mostrar resumen del cambio
            diferencia = nuevo_precio - precio_actual
            porcentaje = (diferencia / precio_actual) * 100

            print(f"\n RESUMEN DEL CAMBIO:")
            print(f"Producto: {nombre}")
            print(f"Precio anterior: S/{precio_actual:.2f}")
            print(f"Precio nuevo: S/{nuevo_precio:.2f}")
            print(f"Diferencia: S/{diferencia:+.2f} ({porcentaje:+.1f}%)")

            aplicar = input("\n¬øAplicar cambio? (s/n): ").lower()
            if aplicar == 's':
                fecha_hoy = datetime.datetime.now().strftime('%Y-%m-%d')
                ajustes = {nombre: nuevo_precio}

                if self.actualizar_precios_por_fecha(fecha_hoy, ajustes):
                    print(" Precio actualizado exitosamente")
                else:
                    print(" Error al actualizar precio")
            else:
                print(" Cambio cancelado")

        except ValueError:
            print(" Precio inv√°lido")

    def actualizar_precios_categoria(self):
        """Aplica un ajuste porcentual a toda una categor√≠a."""
        print("\n ACTUALIZACI√ìN POR CATEGOR√çA")
        print("-" * 40)

        categorias = list(set(item[3] for item in self.catalogo))
        print("\nCategor√≠as disponibles:")
        for i, categoria in enumerate(categorias, 1):
            productos_en_cat = [item for item in self.catalogo if item[3] == categoria]
            print(f"{i}. {categoria} ({len(productos_en_cat)} productos)")

        try:
            seleccion = int(input("\nSeleccione el n√∫mero de categor√≠a: ")) - 1
            if 0 <= seleccion < len(categorias):
                categoria_seleccionada = categorias[seleccion]
                productos_categoria = [item for item in self.catalogo if item[3] == categoria_seleccionada]

                print(f"\n Productos en '{categoria_seleccionada}':")
                for nombre, descripcion, precio, _ in productos_categoria:
                    print(f"‚Ä¢ {nombre:<25}  | ‚Ä¢ {descripcion:<25}  | S/{precio:.2f}")

                porcentaje = float(input(f"\nIngrese el porcentaje de ajuste (+/- ej: 10 para aumentar 10%, -5 para reducir 5%): "))

                print(f"\n VISTA PREVIA - Ajuste del {porcentaje:+.1f}%:")
                ajustes = {}
                for nombre, descripcion, precio, categoria in productos_categoria:
                    nuevo_precio = precio * (1 + porcentaje / 100)
                    ajustes[nombre] = nuevo_precio
                    print(f"‚Ä¢ {nombre:<25}  | ‚Ä¢ {descripcion:<25}  | S/{precio:.2f}")

                confirmar = input(f"\n¬øAplicar ajuste del {porcentaje:+.1f}% a {len(productos_categoria)} productos? (s/n): ").lower()
                if confirmar == 's':
                    fecha_hoy = datetime.datetime.now().strftime('%Y-%m-%d')
                    if self.actualizar_precios_por_fecha(fecha_hoy, ajustes):
                        print(f" Precios de categor√≠a '{categoria_seleccionada}' actualizados")
                    else:
                        print(" Error al actualizar precios")
                else:
                    print(" Cambios cancelados")
            else:
                print(" Selecci√≥n inv√°lida")

        except (ValueError, IndexError):
            print(" Entrada inv√°lida")

    # def submenu_actualizar_stock(self):
    #     """Submen√∫ para actualizar inventario/stock."""
    #     print("\n" + "="*50)
    #     print("üì¶ ACTUALIZACI√ìN DE STOCK/INVENTARIO")
    #     print("="*50)

    #     print("1. Actualizar stock de un producto")
    #     print("2. Entrada de mercanc√≠a (agregar stock)")
    #     print("3. Ajuste de inventario (m√∫ltiples productos)")
    #     print("4. Reporte de stock bajo")
    #     print("0. Cancelar")

    #     try:
    #         opcion = input("\nSeleccione una opci√≥n: ").strip()

    #         if opcion == "1":
    #             self.actualizar_stock_individual()
    #         elif opcion == "2":
    #             self.entrada_mercancia()
    #         elif opcion == "3":
    #             self.ajuste_inventario_multiple()
    #         elif opcion == "4":
    #             self.productos_stock_critico()
    #         elif opcion == "0":
    #             return
    #         else:
    #             print(" Opci√≥n inv√°lida")

    #     except Exception as e:
    #         print(f" Error: {e}")

    # def actualizar_stock_individual(self):
    #     """Actualiza el stock de un producto espec√≠fico."""
    #     print("\nüéØ ACTUALIZAR STOCK INDIVIDUAL")
    #     print("-" * 40)

    #     nombre_producto = input("Ingrese el nombre del producto: ").strip()
    #     producto = self.buscar_producto(nombre_producto)

    #     if not producto:
    #         print(f" Producto '{nombre_producto}' no encontrado")
    #         return

    #     nombre, precio, stock_actual, categoria = producto
    #     print(f"\n‚úÖ Producto: {nombre}")
    #     print(f"Stock actual: {stock_actual}")
    #     print(f"Precio: S/{precio:.2f}")

    #     try:
    #         nuevo_stock = int(input(f"Ingrese el nuevo stock (actual: {stock_actual}): "))

    #         if nuevo_stock < 0:
    #             print(" El stock no puede ser negativo")
    #             return

    #         diferencia = nuevo_stock - stock_actual
    #         print(f"\nCambio de stock: {diferencia:+d} unidades")

    #         confirmar = input("¬øConfirmar cambio? (s/n): ").lower()
    #         if confirmar == 's':
    #             if self.actualizar_stock_inmediato({nombre: nuevo_stock}):
    #                 print(" Stock actualizado exitosamente")
    #             else:
    #                 print(" Error al actualizar stock")
    #         else:
    #             print(" Cambio cancelado")

    #     except ValueError:
    #         print(" Cantidad inv√°lida")

    def entrada_mercancia(self):
        """Registra entrada de nueva mercanc√≠a."""
        print("\nüì• ENTRADA DE MERCANC√çA")
        print("-" * 30)

        productos_entrada = []

        while True:
            print(f"\nProductos registrados: {len(productos_entrada)}")
            for prod in productos_entrada:
                print(f"  ‚Ä¢ {prod['nombre']}: +{prod['cantidad']} unidades")

            print("\n1. Agregar producto a la entrada")
            print("2. Procesar entrada completa")
            print("3. Limpiar lista")
            print("0. Cancelar")

            opcion = input("Seleccione una opci√≥n: ").strip()

            if opcion == "1":
                nombre = input("Nombre del producto: ").strip()
                producto = self.buscar_producto(nombre)

                if producto:
                    nombre_prod, precio, stock_actual, categoria = producto
                    try:
                        cantidad = int(input(f"Cantidad a agregar (stock actual: {stock_actual}): "))
                        if cantidad > 0:
                            productos_entrada.append({
                                'nombre': nombre_prod,
                                'cantidad': cantidad,
                                'stock_anterior': stock_actual,
                                'stock_nuevo': stock_actual + cantidad
                            })
                            print(f" Agregado: {nombre_prod} (+{cantidad})")
                        else:
                            print(" La cantidad debe ser mayor a 0")
                    except ValueError:
                        print(" Cantidad inv√°lida")
                else:
                    print(f" Producto '{nombre}' no encontrado")

            elif opcion == "2":
                if productos_entrada:
                    print("\nüìä RESUMEN DE ENTRADA:")
                    total_productos = len(productos_entrada)

                    for prod in productos_entrada:
                        print(f"‚Ä¢ {prod['nombre']}: {prod['stock_anterior']} ‚Üí {prod['stock_nuevo']} (+{prod['cantidad']})")

                    confirmar = input(f"\n¬øProcesar entrada de {total_productos} producto(s)? (s/n): ").lower()
                    if confirmar == 's':
                        ajustes_stock = {prod['nombre']: prod['stock_nuevo'] for prod in productos_entrada}

                        if self.actualizar_stock_inmediato(ajustes_stock):
                            print(f"Entrada procesada exitosamente")
                            self.registrar_entrada_mercancia(productos_entrada)
                            break
                        else:
                            print(" Error al procesar entrada")
                    else:
                        print(" Entrada cancelada")
                else:
                    print(" No hay productos para procesar")

            elif opcion == "3":
                productos_entrada.clear()
                print(" Lista limpiada")

            elif opcion == "0":
                break

    def registrar_entrada_mercancia(self, productos_entrada):
        """Registra la entrada de mercanc√≠a en un archivo de log."""
        try:
            fecha_hoy = datetime.datetime.now().strftime('%Y%m%d')
            archivo = f"datos/entradas_{fecha_hoy}.txt"

            with open(archivo, 'a', encoding='utf-8') as f:
                f.write(f"ENTRADA DE MERCANC√çA - {datetime.datetime.now().strftime('%d/%m/%Y %H:%M:%S')}\n")
                f.write("-" * 50 + "\n")
                for prod in productos_entrada:
                    f.write(f"{prod['nombre']}: +{prod['cantidad']} unidades (stock: {prod['stock_anterior']} ‚Üí {prod['stock_nuevo']})\n")
                f.write("=" * 50 + "\n\n")

            print(f" Entrada registrada en: {archivo}")

        except Exception as e:
            print(f" No se pudo registrar en archivo: {e}")

    def ajuste_inventario_multiple(self):
        """Permite ajustar el stock de m√∫ltiples productos."""
        print("\n AJUSTE DE INVENTARIO M√öLTIPLE")
        print("-" * 45)

        productos_a_ajustar = []

        while True:
            print(f"\nProductos seleccionados: {len(productos_a_ajustar)}")
            for prod in productos_a_ajustar:
                print(f"  ‚Ä¢ {prod['nombre']}: {prod['stock_anterior']} ‚Üí {prod['stock_nuevo']}")

            print("\n1. Agregar producto para ajustar")
            print("2. Aplicar todos los ajustes")
            print("3. Limpiar lista")
            print("0. Cancelar")

            opcion = input("Seleccione una opci√≥n: ").strip()

            if opcion == "1":
                nombre = input("Nombre del producto: ").strip()
                producto = self.buscar_producto(nombre)

                if producto:
                    nombre_prod, precio, stock_actual, categoria = producto
                    try:
                        nuevo_stock = int(input(f"Nuevo stock para '{nombre_prod}' (actual: {stock_actual}): "))
                        if nuevo_stock >= 0:
                            productos_a_ajustar.append({
                                'nombre': nombre_prod,
                                'stock_anterior': stock_actual,
                                'stock_nuevo': nuevo_stock
                            })
                            print(f" Agregado: {nombre_prod}")
                        else:
                            print(" El stock no puede ser negativo")
                    except ValueError:
                        print(" Stock inv√°lido")
                else:
                    print(f" Producto '{nombre}' no encontrado")

            elif opcion == "2":
                if productos_a_ajustar:
                    print("\n RESUMEN DE AJUSTES:")
                    total_productos = len(productos_a_ajustar)

                    for prod in productos_a_ajustar:
                        diferencia = prod['stock_nuevo'] - prod['stock_anterior']
                        print(f"‚Ä¢ {prod['nombre']}: {prod['stock_anterior']} ‚Üí {prod['stock_nuevo']} ({diferencia:+d})")

                    confirmar = input(f"\n¬øAplicar ajustes a {total_productos} producto(s)? (s/n): ").lower()
                    if confirmar == 's':
                        ajustes = {prod['nombre']: prod['stock_nuevo'] for prod in productos_a_ajustar}

                        if self.actualizar_stock_inmediato(ajustes):
                            print(f" {total_productos} ajustes aplicados exitosamente")
                            break
                        else:
                            print(" Error al aplicar ajustes")
                    else:
                        print(" Ajustes cancelados")
                else:
                    print(" No hay productos para ajustar")

            elif opcion == "3":
                productos_a_ajustar.clear()
                print(" Lista limpiada")

            elif opcion == "0":
                break

    def submenu_gestionar_clientes(self):
        """Submen√∫ para gesti√≥n de clientes."""
        print("\n" + "="*50)
        print("üë• GESTI√ìN DE CLIENTES")
        print("="*50)

        print("1. Ver lista de clientes")
        print("2. Agregar nuevo cliente")
        print("3. Actualizar informaci√≥n de cliente")
        print("4. Cambiar tipo de cliente (regular/premium)")
        print("0. Cancelar")

        try:
            opcion = input("\nSeleccione una opci√≥n: ").strip()

            if opcion == "1":
                self.mostrar_clientes()
            elif opcion == "2":
                self.agregar_cliente()
            elif opcion == "3":
                self.actualizar_cliente()
            elif opcion == "4":
                self.cambiar_tipo_cliente()
            elif opcion == "0":
                return
            else:
                print(" Opci√≥n inv√°lida")

        except Exception as e:
            print(f" Error: {e}")

    def mostrar_clientes(self):
        """Muestra la lista completa de clientes."""
        print("\nüë• LISTA DE CLIENTES")
        print("-" * 60)
        print(f"{'ID':<3} {'Nombre':<20}    {'Apellido':<20}    {'Email'}     {'Tel√©fono':<12}")
        print("-" * 60)

        for cliente in self.clientes:
            print(f"{cliente['id']:<3} {cliente['nombre']:<20} {cliente['apellido']:<20}  {cliente['email']}  {cliente['telefono']:<12}")

    def agregar_cliente(self):
        """Agrega un nuevo cliente."""
        print("\n‚ûï AGREGAR NUEVO CLIENTE")
        print("-" * 30)

        try:
            # # Generar nuevo ID
            # nuevo_id = max(c['id'] for c in self.clientes) + 1

            nombre = input("Nombre completo: ").strip()
            telefono = input("Tel√©fono: ").strip()
            email = input("Email: ").strip()
            mascota = input("Nombre y tipo de mascota (ej: 'Rex - Perro'): ").strip()

            print("\nTipo de cliente:")
            print("1. Regular (5% descuento)")
            print("2. Premium (15% descuento)")
            tipo_opcion = input("Seleccione tipo (1-2): ").strip()

            tipo = "regular" if tipo_opcion == "1" else "premium" if tipo_opcion == "2" else "regular"

            nuevo_cliente = {
                "id": nuevo_id,
                "nombre": nombre,
                "telefono": telefono,
                "email": email,
                "tipo": tipo,
                "mascota": mascota
            }

            print(f"\nüìã RESUMEN DEL NUEVO CLIENTE:")
            print(f"ID: {nuevo_id}")
            print(f"Nombre: {nombre}")
            print(f"Tel√©fono: {telefono}")
            print(f"Email: {email}")
            print(f"Tipo: {tipo}")
            print(f"Mascota: {mascota}")

            confirmar = input("\n¬øConfirmar registro? (s/n): ").lower()
            if confirmar == 's':
                self.clientes.append(nuevo_cliente)
                self.agregar_cliente_bd(nuevo_cliente)
                print(f" Cliente {nombre} agregado con ID {nuevo_id}")
            else:
                print(" Registro cancelado")

        except Exception as e:
            print(f" Error al agregar cliente: {e}")

    def agregar_cliente_bd(self, cliente):
        """Agrega el cliente a la base de datos."""
        try:
            conn = sqlite3.connect('base_datos/veterinaria.db')
            cursor = conn.cursor()

            cursor.execute('''
                INSERT INTO clientes (id, nombre, telefono, email, tipo, mascota)
                VALUES (?, ?, ?, ?, ?, ?)
            ''', (cliente["id"], cliente["nombre"], cliente["telefono"],
                  cliente["email"], cliente["tipo"], cliente["mascota"]))

            conn.commit()
            conn.close()

        except Exception as e:
            print(f" Error al guardar cliente en BD: {e}")

    def busqueda_producto(self, nombre: str) -> Producto:
        """Busca un producto por su nombre en la lista de productos."""
        for producto in self.Catalogo:
            if (producto.nombre.lower() == nombre.lower()):
                return producto
        return None

    def submenu_agregar_productos(self):
        """Submen√∫ para agregar nuevos productos/servicios."""
        print("\nüìã AGREGAR NUEVOS PRODUCTOS")
        print("-" * 45)

        try:
            nombre = input("Nombre del producto: ").strip()

            # Verificar que no exista
            if self.busqueda_producto(nombre):
                print(f" Ya existe un producto con el nombre: '{nombre}'")
                return

            descripcion = input("Descripci√≥n: ").strip()
            precio = float(input("Precio: S/ "))

            print("\nCategorias:")
            for i, cat in self.Categorias.items():
                print(f"{i}. {cat}")
            print(f"{len(self.Categorias) + 1}. Nueva categor√≠a")

            cat_id = int(input("\nSeleccione una categor√≠a: ").strip())
            num_cat = len(self.Categorias)
            try:
                if cat_id in range(1, num_cat + 1):
                    categoria = self.Categorias[cat_id]
                elif cat_id == num_cat + 1:
                    categoria = input("Nombre de la nueva categor√≠a: ").strip()
                else:
                    print(" Opci√≥n inv√°lida")
                    return
            except ValueError:
                categoria = cat_id  # Permitir entrada directa

            nuevo_producto = Producto(
                id_producto=0,
                nombre=nombre,
                descripcion=descripcion,
                precio=precio,
                categoria=categoria
            )

            print(f"\nüìã RESUMEN DEL NUEVO PRODUCTO:")
            print(f"Nombre: {nombre}")
            print(f"Precio: S/{precio:.2f}")
            print(f"Categor√≠a: {categoria}")

            confirmar = input("\n¬øConfirmar agregado? (s/n): ").lower()
            if confirmar == 's':
                self.Catalogo.append(nuevo_producto)
                self.insertar_producto(nuevo_producto)
                print(f" Producto '{nombre}' agregado exitosamente")
            else:
                print(" Agregado cancelado")

        except ValueError:
            print(" Datos inv√°lidos")
        except Exception as e:
            print(f" Error: {e}")

    def insertar_producto(self, producto:Producto):
        """Agrega el producto a la base de datos."""
        try:
            id = self.producto_servicio.agregar_producto(producto)
            producto.id_producto = id

        except Exception as e:
            print(f" Error al guardar producto en BD: {e}")

    def submenu_programar_actualizaciones(self):
        """Submen√∫ para programar actualizaciones futuras."""
        print("\nüìÖ PROGRAMAR ACTUALIZACIONES FUTURAS")
        print("-" * 45)

        print("1. Programar cambio de precios")
        print("2. Programar reposici√≥n de stock")
        print("3. Ver actualizaciones programadas")
        print("0. Cancelar")

        try:
            opcion = input("\nSeleccione una opci√≥n: ").strip()

            if opcion == "1":
                self.programar_cambio_precios()
            elif opcion == "2":
                self.programar_reposicion_stock()
            elif opcion == "3":
                self.ver_actualizaciones_pendientes()
            elif opcion == "0":
                return
            else:
                print(" Opci√≥n inv√°lida")

        except Exception as e:
            print(f" Error: {e}")

    def programar_cambio_precios(self):
        """Programa cambios de precios para una fecha futura."""
        print("\nüí∞ PROGRAMAR CAMBIO DE PRECIOS")
        print("-" * 35)

        try:
            fecha_str = input("Fecha de aplicaci√≥n (YYYY-MM-DD): ").strip()
            fecha_obj = datetime.datetime.strptime(fecha_str, '%Y-%m-%d').date()
            fecha_hoy = datetime.datetime.now().date()

            if fecha_obj <= fecha_hoy:
                print(" La fecha debe ser futura")
                return

            ajustes = {}
            while True:
                producto = input("Producto (Enter para terminar): ").strip()
                if not producto:
                    break

                if self.buscar_producto(producto):
                    try:
                        precio = float(input(f"Nuevo precio para '{producto}': S/"))
                        ajustes[producto] = precio
                        print(f" Agregado: {producto} = S/{precio:.2f}")
                    except ValueError:
                        print(" Precio inv√°lido")
                else:
                    print(f" Producto '{producto}' no encontrado")

            if ajustes:
                print(f"\n RESUMEN DE PROGRAMACI√ìN:")
                print(f"Fecha: {fecha_str}")
                for prod, precio in ajustes.items():
                    print(f"‚Ä¢ {prod}: S/{precio:.2f}")

                confirmar = input("\n¬øConfirmar programaci√≥n? (s/n): ").lower()
                if confirmar == 's':
                    self.guardar_actualizacion_programada("precios", fecha_str, ajustes)
                    print(f" Actualizaci√≥n programada para {fecha_str}")
                else:
                    print(" Programaci√≥n cancelada")
            else:
                print(" No se agregaron productos")

        except ValueError:
            print(" Fecha inv√°lida. Use formato YYYY-MM-DD")

    def ver_actualizaciones_pendientes(self):
        """Muestra las actualizaciones pendientes programadas."""
        print("\nüîç ACTUALIZACIONES PENDIENTES")
        print("-" * 35)

        try:
            archivo_prog = 'datos/actualizaciones_programadas.txt'
            if not os.path.exists(archivo_prog):
                print(" No hay actualizaciones programadas")
                return

            fecha_hoy = datetime.datetime.now().date()
            pendientes_encontradas = False

            with open(archivo_prog, 'r', encoding='utf-8') as f:
                for linea in f:
                    try:
                        if '|' in linea:
                            timestamp, programacion_str = linea.strip().split('|', 1)
                            programacion = eval(programacion_str)
                            fecha_prog = datetime.datetime.strptime(programacion['fecha'], '%Y-%m-%d').date()

                            if fecha_prog > fecha_hoy and programacion.get('estado') == 'programado':
                                if not pendientes_encontradas:
                                    print("üìÖ Actualizaciones pendientes:")
                                    pendientes_encontradas = True

                                print(f"\n‚Ä¢ Fecha: {programacion['fecha']}")
                                print(f"  Tipo: {programacion['tipo']}")
                                if programacion['tipo'] == 'precios':
                                    print("  Cambios:")
                                    for prod, precio in programacion.get('ajustes', {}).items():
                                        print(f"    - {prod}: S/{precio:.2f}")
                                elif programacion['tipo'] == 'stock_update':
                                    print("  Productos:")
                                    for prod, stock in programacion.get('productos', {}).items():
                                        print(f"    - {prod}: {stock} unidades")
                    except:
                        continue

            if not pendientes_encontradas:
                print(" No hay actualizaciones pendientes")

        except Exception as e:
            print(f" Error al consultar actualizaciones: {e}")

    def ver_historial_cambios(self):
        """Muestra el historial de cambios realizados."""
        print("\nüìã HISTORIAL DE CAMBIOS (AUDITOR√çA)")
        print("=" * 50)

        try:
            conn = sqlite3.connect('base_datos/veterinaria.db')
            cursor = conn.cursor()

            cursor.execute('''
                SELECT name FROM sqlite_master
                WHERE type='table' AND name='auditoria_precios'
            ''')

            if not cursor.fetchone():
                print(" No hay registros de auditor√≠a disponibles")
                conn.close()
                return

            cursor.execute('''
                SELECT fecha_cambio, producto_nombre, precio_anterior,
                       precio_nuevo, fecha_registro
                FROM auditoria_precios
                ORDER BY fecha_registro DESC
                LIMIT 20
            ''')

            cambios = cursor.fetchall()
            conn.close()

            if cambios:
                print(f"\nüìä √öLTIMOS {len(cambios)} CAMBIOS DE PRECIOS:")
                print("-" * 80)
                print(f"{'Fecha':<12} {'Producto':<25} {'Anterior':<10} {'Nuevo':<10} {'Estado'}")
                print("-" * 80)

                for fecha_cambio, producto, precio_ant, precio_nuevo, fecha_reg in cambios:
                    diferencia = precio_nuevo - (precio_ant or 0)
                    simbolo = "‚ÜóÔ∏è" if diferencia > 0 else "‚ÜòÔ∏è" if diferencia < 0 else "‚û°Ô∏è"
                    print(f"{fecha_cambio:<12} {producto:<25} S/{precio_ant or 0:<8.2f} S/{precio_nuevo:<8.2f} {simbolo}")
            else:
                print(" No hay cambios registrados")

        except Exception as e:
            print(f" Error al consultar historial: {e}")

    # ========================================================================
    # FUNCIONES DE ARCHIVOS Y UTILIDADES
    # ========================================================================

    def guardar_venta_archivo(self, venta: Dict):
        """Guarda una venta en archivo de texto."""
        try:
            fecha_hoy = datetime.datetime.now().strftime('%Y%m%d')
            archivo = f"datos/ventas_{fecha_hoy}.txt"
            with open(archivo, 'a', encoding='utf-8') as f:
                f.write(f"VENTA - {venta['fecha'].strftime('%d/%m/%Y %H:%M:%S')}\n")
                f.write(f"Cliente: {venta['cliente']} (ID: {venta['cliente_id']})\n")
                f.write("Items:\n")
                for nombre, precio, cantidad, categoria in venta["items"]:
                    f.write(f" - {nombre} x{cantidad} @ S/{precio} = S/{precio*cantidad:.2f}\n")
                f.write(f"Subtotal: S/{venta['subtotal']:.2f}\n")
                f.write(f"Descuento: {venta['descuento_pct']:.1f}%\n")
                f.write(f"Total: S/{venta['total']:.2f}\n")
                f.write("-" * 50 + "\n\n")
        except Exception as e:
            print(f" Error al guardar venta en archivo: {e}")

    def actualizar_precios_por_fecha(self, fecha_efectiva: str, ajustes: Dict[str, float]):
        """Actualiza precios con fecha efectiva."""
        try:
            # Actualizar precios inmediatamente
            actualizados = 0
            for i, (nombre, descripcion, precio, categoria) in enumerate(self.catalogo):
                if nombre in ajustes:
                    nuevo_precio = ajustes[nombre]
                    self.catalogo[i] = (nombre, descripcion, nuevo_precio, categoria)
                    actualizados += 1
                    print(f" {nombre}: S/{precio:.2f} ‚Üí S/{nuevo_precio:.2f}")

            # Registrar cambios en BD
            self.registrar_cambio_precios(fecha_efectiva, ajustes)
            print(f" Se actualizaron {actualizados} productos")
            return True

        except Exception as e:
            print(f" Error al actualizar precios: {e}")
            return False

    def actualizar_stock_inmediato(self, productos_stock: Dict[str, int]):
        """Actualiza stock de productos inmediatamente."""
        try:
            actualizados = 0
            for i, (nombre, precio, stock_actual, categoria) in enumerate(self.catalogo):
                if nombre in productos_stock:
                    nuevo_stock = productos_stock[nombre]
                    self.catalogo[i] = (nombre, precio, nuevo_stock, categoria)
                    actualizados += 1
                    print(f" {nombre}: Stock {stock_actual} ‚Üí {nuevo_stock}")

            # Actualizar en BD
            conn = sqlite3.connect('base_datos/veterinaria.db')
            cursor = conn.cursor()
            for nombre, nuevo_stock in productos_stock.items():
                cursor.execute('''
                    UPDATE productos SET stock = ? WHERE nombre = ?
                ''', (nuevo_stock, nombre))
            conn.commit()
            conn.close()

            print(f" Se actualiz√≥ el stock de {actualizados} productos")
            return True

        except Exception as e:
            print(f" Error al actualizar stock: {e}")
            return False

    def registrar_cambio_precios(self, fecha: str, cambios: Dict[str, float]):
        """Registra cambios de precios en la base de datos para auditor√≠a."""
        try:
            conn = sqlite3.connect('base_datos/restaurante.db')
            cursor = conn.cursor()

            # Insertar cambios
            for producto, precio_nuevo in cambios.items():
                cursor.execute('''
                    SELECT precio FROM productos WHERE nombre = ?
                ''', (producto,))
                resultado = cursor.fetchone()
                precio_anterior = resultado[0] if resultado else None

                cursor.execute('''
                    INSERT INTO auditoria_precios
                    (fecha_cambio, producto_nombre, precio_anterior, precio_nuevo)
                    VALUES (?, ?, ?, ?)
                ''', (fecha, producto, precio_anterior, precio_nuevo))

                # Actualizar precio en la tabla de productos
                cursor.execute('''
                    UPDATE productos SET precio = ? WHERE nombre = ?
                ''', (precio_nuevo, producto))

            conn.commit()
            conn.close()

        except Exception as e:
            print(f" Error al registrar cambios de precios: {e}")

    def guardar_actualizacion_programada(self, tipo: str, fecha: str, datos: Dict):
        """Guarda una actualizaci√≥n programada."""
        try:
            programacion = {
                'fecha': fecha,
                'tipo': tipo,
                'ajustes' if tipo == 'precios' else 'productos': datos,
                'estado': 'programado'
            }

            archivo_prog = 'datos/actualizaciones_programadas.txt'
            with open(archivo_prog, 'a', encoding='utf-8') as f:
                f.write(f"{datetime.datetime.now().isoformat()}|{programacion}\n")

        except Exception as e:
            print(f" Error al guardar programaci√≥n: {e}")

    # ========================================================================
    # VISUALIZACI√ìN DE DATOS (SIMPLIFICADA)
    # ========================================================================

    def generar_graficos_analisis(self):
        """Genera gr√°ficos b√°sicos de an√°lisis."""
        try:
            if not self.ventas:
                print(" No hay datos suficientes para generar gr√°ficos")
                return

            # Crear directorio si no existe
            os.makedirs('reportes/graficos', exist_ok=True)

            # Gr√°fico simple de ventas por d√≠a
            fechas = [v['fecha'].date() for v in self.ventas]
            totales = [v['total'] for v in self.ventas]

            plt.figure(figsize=(10, 6))
            plt.plot(fechas, totales, marker='o')
            plt.title('Ventas por D√≠a - Veterinaria')
            plt.xlabel('Fecha')
            plt.ylabel('Total (S/)')
            plt.xticks(rotation=45)
            plt.tight_layout()
            plt.savefig('reportes/graficos/ventas_diarias.png')
            plt.close()

            print(" Gr√°fico de ventas generado en reportes/graficos/")

        except Exception as e:
            print(f" Error al generar gr√°ficos: {e}")

    def respaldar_datos(self):
        """Crea respaldo de archivos importantes."""
        try:
            timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
            backup_dir = f"datos/backup/backup_{timestamp}"
            os.makedirs(backup_dir, exist_ok=True)

            # Respaldar base de datos
            if os.path.exists('base_datos/veterinaria.db'):
                import shutil
                shutil.copy2('base_datos/veterinaria.db', f"{backup_dir}/veterinaria.db")

            # Respaldar archivos de ventas
            for archivo in os.listdir('datos'):
                if archivo.startswith('ventas_') and archivo.endswith('.txt'):
                    shutil.copy2(f"datos/{archivo}", f"{backup_dir}/{archivo}")

            print(f" Respaldo creado en: {backup_dir}")
            return True

        except Exception as e:
            print(f" Error al crear respaldo: {e}")
            return False

    # ========================================================================
    # MEN√ö PRINCIPAL MEJORADO
    # ========================================================================

    def menu_principal(self):
        """Men√∫ principal mejorado que incluye el submen√∫ de actualizaciones."""
        while True:
            print("\n" + "="*50)
            print("MEN√ö PRINCIPAL - RESTAURANTE")
            print("="*50)
            print("111. Seleccionar mesa")
            print("222. Validar Reserva")
            print("222. ")
            print("1. Mostrar Cat√°logo")
            print("2. Buscar Producto")
            print("3. Procesar Orden")
            print("4. Mostrar Pedidos")
            print("5. Finalizar Compra")
            print("6. Mostrar Historial de Ventas")
            print("7. Reportes y An√°lisis (SQL & Gr√°ficos)")
            print("8. üîÑ ACTUALIZACIONES (Precios, Stock, etc.)")  # ‚Üê NUEVA OPCI√ìN
            print("9. Crear Respaldo de Datos")
            print("0. Salir")
            print("="*50)

            try:
                opcion = input("Seleccione una opci√≥n: ").strip()

                if opcion == "111":
                    num_personas = int(input("Ingrese el n√∫mero de personas: ").strip())
                    self.obtener_mesas_disponibles(num_personas)
                    try:
                        mesa_seleccionada = int(input("Seleccione una mesa: ").strip())
                        if mesa_seleccionada > 0:
                            self.agregar_al_carrito(nombre, mesa_seleccionada)
                        else:
                            print(" La cantidad debe ser mayor a 0")
                    except ValueError:
                        print("Cantidad inv√°lida")
                elif opcion == "1":
                    self.mostrar_catalogo()
                elif opcion == "2":
                    nombre = input("Ingrese el nombre del producto a buscar: ").strip()
                    filtrados = self.filtrar_catalogo(nombre)
                    if filtrados:
                        for p in filtrados:
                            print(f"‚Ä¢ {p.nombre:<25} | {p.descripcion:<45} |    {p.categoria:<45}  |   S/{p.precio:>6.2f}")
                    else:
                        print("Producto no encontrado.")
                elif opcion == "3":
                    nombre = input("Ingrese el nombre del producto a agregar: ").strip()
                    try:
                        cantidad = int(input("Ingrese la cantidad: ").strip())
                        if cantidad > 0:
                            self.agregar_al_carrito(nombre, cantidad)
                        else:
                            print(" La cantidad debe ser mayor a 0")
                    except ValueError:
                        print("Cantidad inv√°lida")
                elif opcion == "4":
                    self.mostrar_carrito()
                elif opcion == "5":
                    try:
                        cliente_id = int(input("Ingrese el ID del cliente: ").strip())
                        self.finalizar_compra(cliente_id)
                    except ValueError:
                        print(" ID de cliente inv√°lido")
                elif opcion == "6":
                    self.mostrar_historial()
                elif opcion == "7":
                    print("\n--- REPORTES Y AN√ÅLISIS ---")
                    self.productos_mas_vendidos()
                    self.ventas_por_cliente()
                    self.productos_stock_critico()
                    self.generar_graficos_analisis()
                elif opcion == "8":  # ‚Üê NUEVA FUNCIONALIDAD
                    self.menu_actualizaciones()
                elif opcion == "9":
                    self.respaldar_datos()
                elif opcion == "0":
                    print("Saliendo del sistema. ¬°Hasta luego! üêæ")
                    break
                elif opcion == "20":
                    self.Gestionar_Reservas()
                else:
                    print(" Opci√≥n inv√°lida. Intente de nuevo.")

            except Exception as e:
                print(f" Ocurri√≥ un error: {e}")

# ============================================================================
# FUNCIONES DE DEMOSTRACI√ìN Y EJEMPLO
# ============================================================================

def crear_datos_ejemplo():
    """Crea datos de ejemplo para demostrar el funcionamiento."""
    productos_csv = [
        ['nombre', 'precio', 'stock', 'categoria'],
        ['Microchip', '25.0', '50', 'Servicios'],
        ['Correa Premium', '35.0', '25', 'Productos'],
        ['Juguete Dental', '18.0', '40', 'Productos'],
        ['Tratamiento Pulgas', '65.0', '20', 'Medicamentos'],
        ['Consulta Especialista', '150.0', '30', 'Servicios']
    ]

    os.makedirs('datos', exist_ok=True)
    with open('datos/productos_nuevos.csv', 'w', newline='', encoding='utf-8') as f:
        writer = csv.writer(f)
        writer.writerows(productos_csv)
    print("Archivo CSV de ejemplo creado: datos/productos_nuevos.csv")

def demo_sistema_completo():
    """Demostraci√≥n completa del sistema con datos de ejemplo."""
    print(" INICIANDO DEMOSTRACI√ìN DEL SISTEMA DE VETERINARIA")
    print("="*60)

    # Crear instancia del sistema
    vet = RestauranteGestion()

    # Crear datos de ejemplo
    crear_datos_ejemplo()

    print("\nüìã SIMULANDO VENTAS DE EJEMPLO...")

    # Venta 1: Cliente premium
    vet.agregar_al_carrito("Consulta General", 1)
    vet.agregar_al_carrito("Vacuna Antirr√°bica", 2)
    vet.finalizar_compra(2)  # Carlos Ruiz (premium)

    # Venta 2: Cliente regular
    vet.agregar_al_carrito("Alimento Premium Perro", 1)
    vet.agregar_al_carrito("Collar Antipulgas", 2)
    vet.finalizar_compra(1)  # Mar√≠a Gonz√°lez (regular)

    print("\nüìä GENERANDO REPORTES Y AN√ÅLISIS...")
    vet.productos_mas_vendidos()
    vet.ventas_por_cliente()
    vet.productos_stock_critico()
    vet.generar_graficos_analisis()

    print("\nüí° DEMOSTRANDO SISTEMA DE ACTUALIZACIONES...")
    # Ejemplo de actualizaci√≥n de precio
    print("üìù Actualizando precio de 'Consulta General' de S/80.00 a S/85.00")
    ajustes = {"Consulta General": 85.0}
    fecha_hoy = datetime.datetime.now().strftime('%Y-%m-%d')
    vet.actualizar_precios_por_fecha(fecha_hoy, ajustes)

    # Ejemplo de actualizaci√≥n de stock
    print("üì¶ Agregando stock: Vacuna Antirr√°bica +10 unidades")
    stock_updates = {"Vacuna Antirr√°bica": 35}  # 25 + 10
    vet.actualizar_stock_inmediato(stock_updates)

    print("\n‚úÖ DEMOSTRACI√ìN COMPLETADA")
    print("üìÅ Revise las carpetas:")
    print(" - reportes/graficos/ (gr√°ficos generados)")
    print(" - datos/ (archivos de ventas y respaldos)")
    print(" - base_datos/ (base de datos SQLite)")

    return vet

def demo_actualizaciones_interactivo():
    """Demostraci√≥n espec√≠fica del sistema de actualizaciones."""
    print("üîÑ DEMO - SISTEMA DE ACTUALIZACIONES INTERACTIVO")
    print("=" * 50)

    # Crear instancia
    res = RestauranteGestion()

    print("\nüìã Estado inicial del cat√°logo:")
    res.mostrar_catalogo()

    print("\nüí° EJEMPLOS DE ACTUALIZACIONES:")

    # 1. Actualizaci√≥n de precio individual
    print("\n1Ô∏è‚É£ Ejemplo: Actualizaci√≥n de precio individual")
    print("   Cambiando 'Consulta General' de S/80.00 a S/85.00")
    ajustes_precio = {"Consulta General": 85.0}
    fecha_hoy = datetime.datetime.now().strftime('%Y-%m-%d')
    res.actualizar_precios_por_fecha(fecha_hoy, ajustes_precio)

    # # 2. Actualizaci√≥n de stock
    # print("\n2Ô∏è‚É£ Ejemplo: Entrada de mercanc√≠a")
    # print("   Agregando 15 unidades a 'Shampoo Medicado'")
    # # Obtener stock actual
    # producto_shampoo = res.buscar_producto("Shampoo Medicado")
    # if producto_shampoo:
    #     stock_actual = producto_shampoo[2]
    #     nuevo_stock = stock_actual + 15
    #     res.actualizar_stock_inmediato({"Shampoo Medicado": nuevo_stock})

    # 3. Ajuste por categor√≠a
    print("\n3Ô∏è‚É£ Ejemplo: Ajuste de precios por categor√≠a")
    print("   Aumentando 10% a todos los productos de 'Medicamentos'")
    productos_medicamentos = [item for item in res.catalogo if item[3] == "Medicamentos"]
    ajustes_categoria = {}
    for nombre, precio, stock, categoria in productos_medicamentos:
        nuevo_precio = precio * 1.1  # Aumento del 10%
        ajustes_categoria[nombre] = nuevo_precio

    if ajustes_categoria:
        res.actualizar_precios_por_fecha(fecha_hoy, ajustes_categoria)

    print("\nüìã Estado final del cat√°logo (despu√©s de las actualizaciones):")
    res.mostrar_catalogo()

    print("\nüìä Consultando historial de cambios:")
    res.ver_historial_cambios()

    print("\n‚úÖ Demo de actualizaciones completado")
    print("üí° Tip: En el men√∫ principal, usa la opci√≥n 8 para acceder a todas las funciones de actualizaci√≥n")

    return res

def main():
    # """Funci√≥n principal que ejecuta el sistema."""
    print("BIENVENIDO AL SISTEMA DE GESTI√ìN PARA RESTAURANTE")
    print("="*60)
    print("Opciones:")
    print("1. Ejecutar demostraci√≥n completa")
    print("2. Demo espec√≠fico de actualizaciones")
    print("3. Iniciar sistema interactivo")
    print("4. Solo crear estructura base")


    try:
        opcion = input("\nSeleccione una opci√≥n (1-4): ").strip()

        if opcion == "1":
            # Ejecutar demostraci√≥n completa
            res = demo_sistema_completo()
            continuar = input("\n¬øDesea continuar con el men√∫ interactivo? (s/n): ").lower()
            if continuar == 's':
                res.menu_principal()

        elif opcion == "2":
            # Demo espec√≠fico de actualizaciones
            res = demo_actualizaciones_interactivo()
            continuar = input("\n¬øDesea continuar con el men√∫ interactivo? (s/n): ").lower()
            if continuar == 's':
                res.menu_principal()

        elif opcion == "3":
            # Iniciar sistema directamente
            res = RestauranteGestion()
            res.menu_principal()

        elif opcion == "4":
            # Solo crear estructura
            res = RestauranteGestion()
            print(" Sistema inicializado. Estructura de datos creada.")

        else:
            print(" Opci√≥n inv√°lida")

    except KeyboardInterrupt:
        print("\n\n¬°Hasta luego!")
    except Exception as e:
        print(f" Error al ejecutar el sistema: {e}")

# ============================================================================
# DOCUMENTACI√ìN PARA ESTUDIANTES
# ============================================================================

"""
üìö GU√çA PARA ESTUDIANTES - SISTEMA DE GESTI√ìN VETERINARIA COMPLETO

üîπ CARACTER√çSTICAS DEL SISTEMA MEJORADO:

1. M√ìDULO 1: SISTEMA BASE EN PYTHON
   - Clases y funciones modulares
   - Estructuras de datos (listas, tuplas, diccionarios)
   - Validaciones completas con try-except
   - Men√∫ interactivo mejorado

2. M√ìDULO 2: BASE DE DATOS SQLITE
   - Tablas: productos, clientes, ventas, detalle_ventas, auditoria_precios
   - Operaciones: INSERT, UPDATE, SELECT
   - Consultas avanzadas con JOIN, GROUP BY, ORDER BY
   - Sistema de auditor√≠a completo

3. M√ìDULO 3: MANEJO DE ARCHIVOS
   - Persistencia en archivos .txt y .csv
   - Sistema de respaldo autom√°tico
   - Estructura de carpetas organizada
   - Logs de entrada de mercanc√≠a

4. M√ìDULO 4: VISUALIZACI√ìN DE DATOS
   - Gr√°ficos con matplotlib
   - An√°lisis b√°sico con pandas
   - Guardado en reportes/graficos/

 SISTEMA DE ACTUALIZACIONES MEJORADO:

1. ACTUALIZACI√ìN DE PRECIOS:
   ‚úÖ Individual (producto por producto)
   ‚úÖ M√∫ltiple (varios a la vez)
   ‚úÖ Por categor√≠a (con porcentajes)
   ‚úÖ Programadas para fechas futuras
   ‚úÖ Historial de cambios (auditor√≠a)

2. GESTI√ìN DE STOCK:
   ‚úÖ Actualizaci√≥n individual
   ‚úÖ Entrada de mercanc√≠a
   ‚úÖ Ajuste de inventario m√∫ltiple
   ‚úÖ Reportes de stock bajo
   ‚úÖ Logs de movimientos

3. GESTI√ìN DE CLIENTES:
   ‚úÖ Agregar nuevos clientes
   ‚úÖ Actualizar informaci√≥n
   ‚úÖ Cambiar tipos (regular/premium)

4. NUEVOS PRODUCTOS:
   ‚úÖ Agregar productos/servicios
   ‚úÖ Validaci√≥n autom√°tica
   ‚úÖ Integraci√≥n con BD

üìã NAVEGACI√ìN DEL SISTEMA:

MEN√ö PRINCIPAL ‚Üí Opci√≥n 8 ‚Üí MEN√ö DE ACTUALIZACIONES
   ‚îú‚îÄ‚îÄ 1. Actualizar Precios
   ‚îÇ   ‚îú‚îÄ‚îÄ Individual
   ‚îÇ   ‚îú‚îÄ‚îÄ M√∫ltiple
   ‚îÇ   ‚îî‚îÄ‚îÄ Por categor√≠a
   ‚îú‚îÄ‚îÄ 2. Actualizar Stock
   ‚îÇ   ‚îú‚îÄ‚îÄ Individual
   ‚îÇ   ‚îú‚îÄ‚îÄ Entrada de mercanc√≠a
   ‚îÇ   ‚îî‚îÄ‚îÄ Ajuste m√∫ltiple
   ‚îú‚îÄ‚îÄ 3. Gesti√≥n de Clientes
   ‚îú‚îÄ‚îÄ 4. Nuevos Productos
   ‚îú‚îÄ‚îÄ 5. Programar Actualizaciones
   ‚îú‚îÄ‚îÄ 6. Ver Pendientes
   ‚îî‚îÄ‚îÄ 7. Historial de Cambios

üöÄ PARA EJECUTAR:
1. Copia todo el c√≥digo en un archivo .py
2. Ejecuta: python archivo.py
3. Selecciona la opci√≥n deseada:
   - Opci√≥n 1: Demo completa
   - Opci√≥n 2: Demo de actualizaciones
   - Opci√≥n 3: Sistema interactivo
   - Opci√≥n 4: Solo inicializar

üí° CONSEJOS PARA ESTUDIANTES:
- Revisen cada funci√≥n para entender su prop√≥sito
- Modifiquen los datos de ejemplo para su negocio elegido
- Experimenten con las diferentes opciones de actualizaci√≥n
- Analicen c√≥mo se integran todos los m√≥dulos
- Usen el sistema de auditor√≠a para rastrear cambios

üéØ CARACTER√çSTICAS DESTACADAS:
- Interfaz completamente interactiva
- Validaciones robustas en todas las entradas
- Confirmaciones paso a paso
- Res√∫menes antes de aplicar cambios
- Sistema de auditor√≠a completo
- Manejo de errores comprehensivo
- Estructura modular y extensible

Este sistema cumple COMPLETAMENTE con todos los requisitos del proyecto
y agrega funcionalidades avanzadas que demuestran un nivel profesional.
"""

# Ejecutar el sistema si se ejecuta directamente
if __name__ == "__main__":
    menu_principal()



